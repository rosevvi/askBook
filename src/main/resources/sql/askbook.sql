/*
 Navicat Premium Data Transfer

 Source Server         : 本机
 Source Server Type    : MySQL
 Source Server Version : 50724
 Source Host           : localhost:3306
 Source Schema         : study

 Target Server Type    : MySQL
 Target Server Version : 50724
 File Encoding         : 65001

 Date: 11/05/2023 15:46:49
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for answer
-- ----------------------------
DROP TABLE IF EXISTS `answer`;
CREATE TABLE `answer`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `data` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `user_id` bigint(11) NOT NULL COMMENT '用户id',
  `question_id` bigint(11) NOT NULL COMMENT '问题id',
  `images` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '图片',
  `create_user` bigint(11) NOT NULL COMMENT '创建人',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_user` bigint(11) NOT NULL COMMENT '更新人',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '回答' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of answer
-- ----------------------------

-- ----------------------------
-- Table structure for collect
-- ----------------------------
DROP TABLE IF EXISTS `collect`;
CREATE TABLE `collect`  (
  `id` bigint(30) NOT NULL COMMENT '主键',
  `user_id` bigint(30) NOT NULL COMMENT '用户id',
  `text_id` bigint(30) NULL DEFAULT NULL COMMENT '文章id',
  `question_id` bigint(30) NULL DEFAULT NULL COMMENT '问题id',
  `to_user_id` bigint(20) NOT NULL COMMENT '收藏的那个用户的id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '收藏' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of collect
-- ----------------------------
INSERT INTO `collect` VALUES (1646690644200009730, 1646127543398469633, NULL, 1646685927780659202, 1646684626040664065, '2023-04-14 09:43:38');
INSERT INTO `collect` VALUES (1646690675372077057, 1646127543398469633, NULL, 1646686117501612033, 1646684626040664065, '2023-04-14 09:43:46');
INSERT INTO `collect` VALUES (1646690706380566529, 1646127543398469633, NULL, 1646688173683650562, 1646686871436144642, '2023-04-14 09:43:53');
INSERT INTO `collect` VALUES (1646690863025238018, 1646684626040664065, NULL, 1646683893044097025, 1646127543398469633, '2023-04-14 09:44:30');
INSERT INTO `collect` VALUES (1646690889403215873, 1646684626040664065, NULL, 1646684126339674113, 1646127543398469633, '2023-04-14 09:44:37');
INSERT INTO `collect` VALUES (1646690927135174658, 1646684626040664065, NULL, 1646687543174901761, 1646686871436144642, '2023-04-14 09:44:46');
INSERT INTO `collect` VALUES (1646690999746965505, 1646686871436144642, NULL, 1646683893044097025, 1646127543398469633, '2023-04-14 09:45:03');
INSERT INTO `collect` VALUES (1646691022253600769, 1646686871436144642, NULL, 1646684126339674113, 1646127543398469633, '2023-04-14 09:45:08');
INSERT INTO `collect` VALUES (1646691055422156801, 1646686871436144642, NULL, 1646688647191212033, 1646684626040664065, '2023-04-14 09:45:16');
INSERT INTO `collect` VALUES (1646691081217126401, 1646686871436144642, NULL, 1646689039190863874, 1646127543398469633, '2023-04-14 09:45:22');
INSERT INTO `collect` VALUES (1646848320632537089, 1646127543398469633, 1646746525411348482, NULL, 1646686871436144642, '2023-04-14 20:10:11');
INSERT INTO `collect` VALUES (1646848356879712257, 1646127543398469633, 1646747507725733889, NULL, 1646686871436144642, '2023-04-14 20:10:20');
INSERT INTO `collect` VALUES (1646848387556851713, 1646127543398469633, 1646749260026253314, NULL, 1646686871436144642, '2023-04-14 20:10:27');
INSERT INTO `collect` VALUES (1646848447334072322, 1646684626040664065, 1646844546065121282, NULL, 1646686871436144642, '2023-04-14 20:10:41');
INSERT INTO `collect` VALUES (1646848480771063810, 1646684626040664065, 1646844942946942978, NULL, 1646127543398469633, '2023-04-14 20:10:49');
INSERT INTO `collect` VALUES (1646848515260825602, 1646684626040664065, 1646846797584285697, NULL, 1646127543398469633, '2023-04-14 20:10:58');
INSERT INTO `collect` VALUES (1646848575822381057, 1646686871436144642, 1646133188969402370, NULL, 1646127543398469633, '2023-04-14 20:11:12');
INSERT INTO `collect` VALUES (1646848611494936577, 1646686871436144642, 1646843841380106242, NULL, 1646127543398469633, '2023-04-14 20:11:21');
INSERT INTO `collect` VALUES (1646848650644570114, 1646686871436144642, 1646844211426770945, NULL, 1646684626040664065, '2023-04-14 20:11:30');
INSERT INTO `collect` VALUES (1646848676976410625, 1646686871436144642, 1646846221270138882, NULL, 1646684626040664065, '2023-04-14 20:11:36');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint(30) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `data` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容',
  `user_id` bigint(11) NOT NULL COMMENT '用户id',
  `answer_id` bigint(200) NULL DEFAULT NULL COMMENT '回答id',
  `text_id` bigint(200) NULL DEFAULT NULL COMMENT '文章id',
  `comment_id` bigint(200) NULL DEFAULT 0 COMMENT '评论id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `to_user_id` bigint(20) NOT NULL COMMENT '评论的那个用户的id',
  `question_id` bigint(20) NULL DEFAULT NULL COMMENT '问题id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
  `id` bigint(30) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `create_user` bigint(21) NOT NULL COMMENT '创建人',
  `update_user` bigint(21) NOT NULL COMMENT '更新人',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `icon` bigint(255) NULL DEFAULT 0 COMMENT '热度',
  `solved` int(10) NULL DEFAULT 0 COMMENT '是否解决   0未解决  1已解决',
  `images` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '图片',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1646689039190863875 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '问题' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (1646132967879249922, '什么是循环依赖?', '什么是循环依赖，Spring是如何解决的，为什么要使用三级缓存来解决，二级缓存不能吗?', 1646127543398469633, 1646127543398469633, '2023-04-12 20:47:38', '2023-04-12 20:47:38', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646683893044097025, '为什么我学个 JAVA 就已经耗尽所有，而有些人还能同时学习多门语言？', '各种框架以及中间件，分布式微服务，权限，安全，优化，就已经一辈子学不完了，其它学习多门语言的是怎么做到的', 1646127543398469633, 1646127543398469633, '2023-04-14 09:16:49', '2023-04-14 09:16:49', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646684126339674113, '怎么吃透一个java项目？', '先说一下自己的情况：就是对着视频敲Java项目，其中遇到的BUG还能解决，但就是每次敲完一个项目，就感觉很空虚，项目里面的知识点感觉懂了但又好像没懂，我应该怎样才能掌握一个项目所用的知识点呢？至少不至于过了一头半个月就想不起来这个项目是什么东西了。写博客记录？，画思维导图？还是怎么样呢？有没有过来人能给点经验呢？', 1646127543398469633, 1646127543398469633, '2023-04-14 09:17:44', '2023-04-14 09:17:44', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646685927780659202, '程序员怎么尽快学会某项技术，达到应付面试水平?', '以java面试为例，每一年的重点都是不一样的，招聘要求中可能出现你没有使用过的技术， 如：RPC、springboot、docker等。如果，你3个月后要去面试，你心仪的公司，招聘要求上出现这样的你没有用过的技术，你不知道面试官会问这个技术的那些问题。问题1：你曾经是否遇到过类似这样的问题，你是怎么处理的？问题2：你是如何学习某一项技术，达到在被面试官问到的时候能说清楚的水平？', 1646684626040664065, 1646684626040664065, '2023-04-14 09:24:54', '2023-04-14 09:24:54', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646686117501612033, '程序员如何在实力不强的情况下在几年之内实现逆袭??', '除了少数人天赋异禀，大部分人总是平庸的，碌碌无为的时光总是一晃而逝。业界流传着中年危机和职场内卷，怎样赶在职场危机之前实现逆袭?前提是实力一般，没有特别突出和擅长的领域，当然或许不仅仅是程序员，可以延伸到很多职业', 1646684626040664065, 1646684626040664065, '2023-04-14 09:25:39', '2023-04-14 09:25:39', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646686307822350337, 'SpringBoot开发使用Mybatis还是Spring Data JPA??', 'Spring Data JPA项目实战中体验如何', 1646684626040664065, 1646684626040664065, '2023-04-14 09:26:24', '2023-04-14 09:26:24', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646687543174901761, '对于后端开发，响应式编程真的是大势所趋吗？', 'Spring5将响应式编程的地位同原servlet栈一致，但现在响应式编程貌似又不温不火，很奇怪', 1646686871436144642, 1646686871436144642, '2023-04-14 09:31:19', '2023-04-14 09:31:19', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646687853217853441, '为什么很多大学生的手机都默认字体，尤其是男生？', '我发现很多人的手机换主题壁纸铃声就是不换字体，这是为什么？更新问题：本人只换了一个楷体，感觉很好看，字库也很大，默字体不能覆盖的字都能显示，感觉比系统字体好看多了，为什么很多人的手机还在用冷冰冰的无衬线字体？', 1646686871436144642, 1646686871436144642, '2023-04-14 09:32:33', '2023-04-14 09:32:33', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646688041907007489, '搞 Java 的年薪 40W 是什么水平？', '前段时间跟同学聊天，她说她老公在一个游戏公司，年薪 40W，Java 后台开发。这是一个什么样的水平，求大神详细说一下。本人目前也是搞 Java 的，不知道到这个地步还需要多久。', 1646686871436144642, 1646686871436144642, '2023-04-14 09:33:18', '2023-04-14 09:33:18', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646688173683650562, '对于被jetbrains系IDE惯坏了的学生，如果不得不放弃使用，有没有什么好的替代方案？', '题主平时用linux系统，写C语言较多，所以经常用clion，但是clion毕竟是收费的，现在我用的是学生账号，也曾经用过破解文件，但这些骚操作有可能从某个时候开始就不能使了（比如我毕业之后就不知道还能不能用学生账号）。如果真的不得不放弃，是否有什么替代方案，能提供相对比较好的体验？主要是jetbrains系的语法高亮、代码补全真的很强大，还原生支持git（虽然我用得还不太熟练），以及一些别的强大之处，我是真的被惯坏了。', 1646686871436144642, 1646686871436144642, '2023-04-14 09:33:49', '2023-04-14 09:33:49', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646688417360130049, '吴亦凡会后悔当初没有直接支付都美竹800万吗？', '都美竹最初的愿望是认识吴亦凡，其次是和吴亦凡谈恋爱，后来是希望吴亦凡道歉并支付800万，再后来是要求他退圈，现在吴亦凡涉嫌强奸被刑拘了，大概率是九年甚至十一年的有期徒刑，（别问我为什么），你觉得吴亦凡会后悔当初没有直接支付800万吗？那么他当初为什么就是不付呢？', 1646684626040664065, 1646684626040664065, '2023-04-14 09:34:47', '2023-04-14 09:34:47', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646688647191212033, '我爸对计算机行业的看法，是否准确？', '现在有很多人想当码农，他们都很努力，无论是刷题，还是加班，看上去内卷的很厉害。我看见他们这种状态，觉得自己也非学计算机不可，而且也必须很拼。我问了我爸的意见，我爸跟我说：“无论你从事什么行业，首先要对市场有概念。你选择了一个行业，首先要去想怎么切入市场。对于计算机行业而言，市场被大公司所占据，对于个人而言，切入市场的方式就是迎合这些公司的招聘要求，这相当于从被动的角度去解决问题。但是如果你有自己的爱好，对这个爱好能保持长期的热情，并且这个爱好也可以切入市场，这时候，你可以选择去迎合大公司，但是同样，你也可以从社会的供需关系来切入市场，从最底层来塑造一个模式，利用复利的原理来扩大这个模式。这个模式，很可能不是技术书、面试题所能衡量的，它可能并不是高科技，也不漂亮，但是你的目的是让它增长，然后再复制这个模式。如果你的兴趣就在这里，那你就仔细思考思考这个社会的经济形势和人与人之间的利益关系，想明白之后，塑造你的产品，为别人创造价值。慢慢你会发现，你自己有一个小圈子，在这个圈子里，你了解其中的一切，你明白游戏规则，这里的一切你做主。相反，如果你只知道学技术，刷题，即便你的技术再好，内心深处仍然会有被别人支配的恐惧感。而且，你时常会疑问，技术到底学多少，才能没有恐惧感？答案是，越学技术，很可能你会越质疑自己。因为你在一个无比复杂的圈子里，但是很难塑造自己的圈子，就是那个你自己做主的圈子”', 1646684626040664065, 1646684626040664065, '2023-04-14 09:35:42', '2023-04-14 09:35:42', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646688765579636738, 'Spring都有Kotlin版本了，为什么却没什么人用Spring for kotlin？', 'Spring 5开始支持Kotlin了，为什么用spring for kotlin的人还这么少？是kotlin做服务端开发不方便？还是kotlin本身有缺陷？还是其他的原因？', 1646127543398469633, 1646127543398469633, '2023-04-14 09:36:10', '2023-04-14 09:36:10', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `question` VALUES (1646689039190863874, 'linux直接安装nginx这些东西好还是安装docker容器再进行部署好？', '我觉得这两个差不多吧，但是docker要便于管理点，只是启动命令这些相对于直接安装nginx这些命令要少些，各位看官举得呢', 1646127543398469633, 1646127543398469633, '2023-04-14 09:37:16', '2023-04-14 09:37:16', 0, 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');

-- ----------------------------
-- Table structure for question_bridge
-- ----------------------------
DROP TABLE IF EXISTS `question_bridge`;
CREATE TABLE `question_bridge`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `question_id` bigint(21) NOT NULL COMMENT '问题id',
  `type_id` bigint(21) NOT NULL COMMENT '问题分类id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1646689039190863876 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '问题、分类桥接' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of question_bridge
-- ----------------------------
INSERT INTO `question_bridge` VALUES (1646132967879249923, 1646132967879249922, 1);
INSERT INTO `question_bridge` VALUES (1646683893182509058, 1646683893044097025, 1);
INSERT INTO `question_bridge` VALUES (1646684126339674114, 1646684126339674113, 1);
INSERT INTO `question_bridge` VALUES (1646685927843573761, 1646685927780659202, 2);
INSERT INTO `question_bridge` VALUES (1646686117501612034, 1646686117501612033, 2);
INSERT INTO `question_bridge` VALUES (1646686307822350338, 1646686307822350337, 2);
INSERT INTO `question_bridge` VALUES (1646687543246204930, 1646687543174901761, 3);
INSERT INTO `question_bridge` VALUES (1646687853217853442, 1646687853217853441, 4);
INSERT INTO `question_bridge` VALUES (1646688041907007490, 1646688041907007489, 5);
INSERT INTO `question_bridge` VALUES (1646688173683650563, 1646688173683650562, 6);
INSERT INTO `question_bridge` VALUES (1646688417360130050, 1646688417360130049, 7);
INSERT INTO `question_bridge` VALUES (1646688647191212034, 1646688647191212033, 8);
INSERT INTO `question_bridge` VALUES (1646688765579636739, 1646688765579636738, 9);
INSERT INTO `question_bridge` VALUES (1646689039190863875, 1646689039190863874, 10);

-- ----------------------------
-- Table structure for text
-- ----------------------------
DROP TABLE IF EXISTS `text`;
CREATE TABLE `text`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `data` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '内容',
  `sort` int(11) NULL DEFAULT 0 COMMENT '排序',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `create_user` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建人',
  `update_time` datetime NOT NULL COMMENT '更新时间',
  `update_user` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '更新人',
  `icon` bigint(11) NULL DEFAULT 0 COMMENT '热度',
  `images` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '图片',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1646846797584285698 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of text
-- ----------------------------
INSERT INTO `text` VALUES (1646133188969402370, '关于spring循环依赖', '关于源码好多文章都写了源码，而且源码还是要看视频学着去看才可能看的懂，这里就不贴了，主要是简介明了的说一下循环依赖以及Spring中是如何解决的。什么是循环依赖大家了解过套娃没，挺类似的，不过这个是A套B，B又套A，死循环了，所以就有了循环依赖的问题。在创建A的时候发现A中的属性需要B对象，那就先去创建B对象，又发现B中的属性需要A对象，那又去创建A，形成死循环，这就是循环依赖。在了解Spring解决循环依赖问题之前，需要了解注入属性的方式、Spring中的三级缓存、bean的创建过程.关于注入属性的方式.上面说到创建A时B属性的注入，如果是构造方法去注入，那循环依赖问题没有方法解决，如果是Set方法注入，那就可以使用三级缓存来解决，Spring中就是这样的解决的。Bean的大致创建过程-实例化—设置属性—初始化.Spring中的三个缓存是什么-一级缓存：singletonObjects，存放初始化后的单例对象二级缓存：earlySingletonObjects，存放实例化，未完成初始化的单例对象（未完成属性注入的对象）三级缓存：singletonFactories，存放ObjectFactory对象都是Map集合单例对象先实例化存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中。Spring是如何解决循环依赖问题的？上面说到Spring是使用三级缓存（Map）解决的循环依赖问题，那具体是怎么做的，看下面的步骤。假设A依赖B，B依赖A，Spring创建A实例的过程如下：1、A依次执行doGetBean方法、依次查询三个缓存是否存在该bean、没有就createBean，实例化完成（早期引用，未完成属性装配），放入三级缓存中，接着执行populateBean方法装配属性，但是发现装配的属性是B对象，走下面步骤。2、创建B实例，依次执行doGetBean、查询三个缓存、createBean创建实例，接着执行populateBean发现属性中需要A对象。3、再次调用doGetBean创建A实例，查询三个缓存，在三级缓存singletonFactories得到了A的早期引用（在第一步的时候创建出来了），将它放到二级缓存并移除3级缓存并返回，B完成属性装配，一个完整的对象放到一级缓存singletonObjects中。4、B完成之后就回到A了，A得到完整的B，肯定也完成全部初始化，也存入一级缓存中。解决了循环依赖问题。这里可能很多初学者很蒙，什么是早期引用，其实学过C语言的指针的话就比较好理解了，这里的引用就是地址，所以先开辟内存而不封装属性，我后面再给它封装属性，那引用得到的永远是这个地址的最新值，所以就可以先给引用地址后面再封装属性值，这个一定要与传值区分开来，单纯的传值和传地址是不一样的为什么不使用二级缓存?如果仅仅是解决循环依赖问题，二级缓存也可以，但是如果注入的对象实现了AOP，那么注入到其他bean的时候，不是最终的代理对象，而是原始的。通过三级缓存的ObjectFactory才能实现类最终的代理对象。一级缓存能不能解决循环依赖问题？可以解决，但是因为初始化完成和未初始化完成的都放在这个map中，拿到的可能是没有完成初始化的，属性都是空的，直接空指针异常。', 0, '2023-04-12 20:48:31', '1646127543398469633', '2023-04-12 20:48:31', '1646127543398469633', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646746525411348482, '我干了8年前端，告诉你现在培训前端还能不能找到工作！', '观点：如果你还是以前的思维来学习前端，那你肯定是找不到工作！我做前端工作有将近8年的时间，蚂蚁金服做过2年，因为加班太多离职了。目前在一家国企上市公司，一年能拿三四十个左右，对比头部互联网公司来说，国企的技术人员工资真的很低，但是非常适合养老，我目前很享受这种状态。市场需求：根据我的观察，目前市场上其实并不“缺人”，人真的挺多的，每年毕业这么多学生，肯定有很多人来学习前端找前端的工作，投简历的求职者确实很多，但现在企业现在缺的是“优秀的开发者”。现在人虽然多，但是多数都是一些滥竽充数的人，学个网页三剑客就敢出来找前端的工作，让我觉得现在的前端真的是烂白菜。10月份我看了50份简历，最终只有一个被邀请到公司进行面试，其他的49份简历连让他们面试的欲望都没有，这就是目前的现状，质量是一年比一年差，比我们那个时候真的差太多，就跟男足差不多。培训还能不能找到工作？如果你现在还在指望参加一个线下培训班就可以找到前端的工作，那我敢肯定你这学费绝对打水漂。很多人看不到市场的变化。最近几年的市场，已经从最开始的“批量招聘”转变为“精准招聘”，以前这行业严重缺人的时候，培训班的作用就是批量培训后，有公司招聘他们进入公司，公司在派人带一带，大概几个月就可以上手做项目。而现在如果你还是以前的那种思维，用以前那种培训的方式，来应对如今的招聘市场，那必然找不到工作，培训出来的人真的是太烂了，真的是啥都不会那种，经验丰富的面试官聊一会就能看得出来。现在web前端的工作还能不能做？做绝对可以做，并且我认为前端是一个非常好的职位，有特别大的发展潜力！前端现在不仅仅是前端，目前的前端可以向很多领域渗透，它已经不是曾经那个网页三剑客的时代了，你要知道现在已经开始提及web3.0时代，无风不起浪，该来的总会来的。但绝不是你以为参加个培训就能就业，这种走捷径的想法赶紧放弃。前端目前的工资是一年比一年高，那你想啊，工资越来越高，伴随着的工作难度，以及你需要学习的知识肯定越来越多，这是相辅相成的。所以问题就落实到“学”这件事上面。如果你想做前端的工作，那绝对不是培训可以解决的，而是需要你去“学”。其实就是需要你花费很多时间，如果你是学生，你可以利用在学校大量的时间都在学前端，只要时间足够久，你的技术能力，你的知识面就是水涨船高，找工作自然不是问题。可问题是现在很多人都是临时抱佛脚，觉得自己努力学几个月就能高薪就业，现实会啪啪啪打你的脸。学习代码就是日积月累的过程，如果你没有耐心，时间不够，代码的量不够，你肯定做不了技术的工作。现在缺的是中高级技术人才，非常缺，非常缺的那种现状，所以你想要前端的工作，必须要以这样的定位去学，把基础打好，理论知识搞明白，搞两个像样的项目，现在市场都是缺这样的人。我提倡的学习方式是：自己学习+有人指导学习始终都是自己一个人的事情，你得找到属于自己的学习方法，有自己的学习习惯，自己总结出来的学习心得，只有这样你学什么知识才会快。你参加培训也好，不参加培训也好，最终都得靠你自己，因为有太多的事情都需要你身体力行亲自去做才行，别人根本帮不了你做具体的事，所以必须要明白这个道理，学习永远都是自己的事情。除了靠自己之外，还应该明白“借助外力”，那些身体力行是需要自己亲自去做，但是有些层次的问题是我们目前水平无法解决的，所以这个时候就需要外界的帮助。尤其是学习技术，有一个牛逼点的人去带带我们，确实可以少走非常多的弯路，就比如一个小bug你自己由于没有经验，你可能几个小时都解决不了，但是有经验的人他可能一分钟就能解决，所以在这样的问题上，我们就没有必要浪费时间，就要懂得借助外力来提高自己做事的效率。所以你们学前端的人，就找身边的亲戚朋友带一带自己，如果你身边没这样的人，就来问我。下面是我工作8年时间结交的很多前端技术人员，是一个非常活跃气氛很好的前端交流群，如果你在学习前端的过程中有诸多的疑问，可以在这里问，基本都是自学过来的，都有很多自学的心得，平时大家有不懂的问题也可以问我，我非常愿意解答各种技术问题', 0, '2023-04-14 13:25:41', '1646686871436144642', '2023-04-14 13:25:41', '1646686871436144642', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646747507725733889, '毛主席给我们攒下的三大红利已经消耗殆尽，以后得靠我们自己了！', '从1978年至2022年，咱们在各方面都取得了堪称伟大的成就。GDP增长超300倍，从世界第九一跃成为世界第二，同期美国GDP增长约11倍、印度GDP增长约25倍，无论怎么比，增速优势都十分巨大，创造了一个世界经济史上难以超越的奇迹。交出了如此优秀的成绩单，与时俱进的改革开放政策居功至伟，但这只是前提条件之一，毕竟学习咱们“成功经验”的国家不在少数，例如越南、埃塞俄比亚、塞尔维亚、古巴等，但它们都没能复制“中国奇迹”，有的甚至出现了倒退。虽然各个国家的国情不同，但这样的事实也在提醒我们：中国与其他国家相比，确实存在一些不可复制的“发展红利”。这些“红利”到底是什么，社会各界众说纷纭。本文仅从唯物史观出发、做一些粗浅的分析，仅供参考。第一大红利：毛主席时代进行的土地改革，使中国获得了巨大的人力成本优势。上世纪八九十年代，“亚洲四小龙”开始产业升级，劳动力密集型的纺织服装、小商品制造等行业只能向外转移，从当时的国际格局来看，亲西方的印度、近港口的东南亚都是不错的选择，然而，最终这些产业绝大多数都转入了中国。资本是要赚钱的，当年“四小龙”不愿意继续做纺织服装这类产业的根本原因，在于高昂的用工成本；而他们之所以选择中国，也是因为中国的劳动力最为廉价。1990年前后，中国农民工月薪普遍只有200元块左右，即使到2000年前后、一个月也只能拿到千把块钱——年代并不久远，大家可以问问身边的长辈求证下。同时期，日本平均月薪是咱们的50倍以上，“四小龙”月薪是咱们的20倍以上，就连泰国月薪都是咱们的三四倍……当然这对比的是全社会的平均水平，中国农民工的真实成本、大概比这个还要低个三分之一左右。如此巨大的人力成本优势，哪个国家能比得了？据统计，八十年代外出务工的农民工高达1.2亿，他们广泛从事纺织服装、小商品等低端制造行业，可以说，正是这1.2亿每月只拿一两百块工资的农民工，帮中国赚到了改革开放第一桶金。那么问题来了，为什么中国农民工能接受这么低的工资？因为他们有土地。在最初的乡镇企业中，农民工吃住都是自己的，也不需要企业帮他们买保险，虽然一个月只挣一两百，但这些钱就是纯收入；九十年代以后，农民工以村庄为单位结伴外出务工，活动范围仅限于工厂和工地，基本没有消费活动，挣的钱全部寄回家。工资≈纯收入，试问，还有哪个国家能做到？在其他人力资源大国、比如印度，由于没有进行过土地改革，企业招的都是纯粹的工人，社保是必须要买的，工资也不能低，因为工厂是工人唯一的收入来源。如果同时期只发给印度纺织工人两百块月薪，他们恐怕会死。这个逻辑，一直到现在都是成立的。中国之所以能在三四十年的时间里维持低端产业的超低工资、保持不可替代的人力成本优势，本质上就是因为咱们进行过土地改革。毕竟，就算管理再先进、人民再勤劳，也不可能把人力成本压低到生活成本以下。所以，“中国制造”最初的核心竞争力，其实来源于1950的那一场、人类历史上规模最大的土地改革。当然，如今的“中国制造”早已完成升级、不能再去标榜“低成本”，但我们要记住，如果没有土改、没有整整两代农民工的付出，我们是不可能走到今天这一步的。第二大红利：毛主席时代的“人口大爆炸”和普惠教育，让中国享受了长达三十多年的人力资源红利。新中国资源匮乏、缺少资本积累，想快速发展经济，唯一有可能的突破口就是人力资源。1949年中国总人口约有5.4亿，1979年达到9.75亿，短短三十年时间里，人口净增值达到了4.35亿。统计了一下这三十年出生的人口数量，竟然达到了惊人的6.4亿。这六亿多人，就是改革开放后各行各业的主力军。任何一个国家，如果能拥有六亿规模的青壮年劳动力，想原地踏步都困难。大家看看现在的印度，虽然管理水平一塌糊涂，还不是发展得风生水起——人力资源是客观的，只要数量足够，就一定会带来经济增长。与印度线性增长的节奏相比，中国人口增长具有特殊的“节奏”：建国后三十年出生的人口比1949年总人口还多，而八十年代咱们就推行了计划生育政策。这意味着：1949-1979年出生的这6.4亿人，养老和子女教育负担都非常轻，他们可以全身心地投入到生产建设中去。大家稍微观察下，就会发现五六七十年代出生的那一批人，普遍热爱工作、敢打敢拼、成就感也较高，而八零九零后相对来说就比较丧，我们从人口角度，也能找到一些原因。所以，不要动不动就拿道德去绑架年轻人。毛主席给下一代创造的是什么条件？我们给下一代创造的又是什么条件？中国的“人口发展节奏”，是其他国家学不来的。因为1949-1979年中国为了争取独立与发展，采取了“穷过渡”的方阵，大部分资源都投入到工业建设中去了，人民群众长期勒紧裤腰带过日子，在这种情况下，鼓励生育其实是非常困难的。但我们做到了，靠的仅仅是那句“人多力量大”的号召、以及对“未来会更好”的坚定信念。刺激人口增长绝非易事，经过这些年的折腾，相信大家都有体会。当年新中国在那么困难的情况下，用30年时间培育了6.4亿劳动力，不仅生下了他们、而且给了他们基本的教育医疗保障，这的确是一项堪称伟大的创举。客观而言，那一代掌舵者制定的人口策略是有点吃力不讨好的，想象一下，在30年时间里抚养教育6.4亿人口、规模已经超过了1949年的全国人口，这是什么概念？我们不妨做一个类比，现在的中国人口是14亿，如果我们现在定一个目标、要在30年内养育超过14亿人口，这压力该有多大？把这个目标分解一下，大概就是这样的：从现在开始，每对夫妻要生育六七个小孩，同时还要赡养四个老人。试问，有几个人能扛得住？所以，那个年代之所以很苦，是有着复杂的历史原因的。我们不能只看到这七八个小孩长大后各个都能赚钱养家的好处、而不看养育他们的艰苦过程。第三大红利：毛主席时代追求平等，强势瓦解各种利益集团，这才有了八九十年代充满活力的经济局面。有个道理，很简单，但很多人却不愿意去相信——有些人之所以能取得巨大的成功，不是因为他自己有多厉害，而是因为时代的蛋糕还没分完；如果蛋糕分完了，就算他再怎么努力、顶多也就只能混个温饱。八九十年代，中华大地遍地是黄金、到处是机会，只要你胆大、敢闯，大概率都能混得风生水起。现在问大家一个问题：那个时候、建国都三四十多年了，怎么还有这么多机会呢？这正常吗？这个问题，没有能力给出答案，但我可以提供一横一纵两个类比维度，大家可以自行得出结论。横向维度：印度、韩国、朝鲜这些二战后建立的国家，发展到八九十年代，留给毫无背景的年轻人闯荡的机会多不多呢？纵向维度：从1979年到现在有四十多年了，咱们自己的各行各业是个什么局面？留给普通人的机会多不多呢？中国在八九十年代展现出来的经济活力、绝对是人类文明史上罕有的。一方面，经过三十年的发展，新中国打造了完备的工业体系，拥有了足以自卫的军工系统，科教文化都发展到了一定的水平，人力资源储备更是相当充实，经济发展的土壤已经非常肥沃了；另一方面，各行各业都没有形成“山头”，巨大的“财富蛋糕”散落一地，打拼必有回响，付出必有回报，乾坤未定，你我皆为黑马。中国的重量级企业家，基本都是在八九十年代开始创业的；科教文卫各个领域的领头羊，也基本都是在那个年代闯出来的。试想，如果这片东方大地过早形成了各种“山头”，上面这些“行业领袖”、恐怕在出道时就会碰得头破血流；至少，想白手起家、做到行业领头羊的水平，这几乎是不太可能的。打压既得利益集团，放在哪里都是个超级难题，但这道坎是必须要跨过去的，只有把这个问题解决好了，社会才会繁荣昌盛。在中国历史上，我们很容易发现这样的规律：盛世之前，通常都会出现一次大规模动乱。西汉初期的七国之乱，诸侯势力遭到严重消耗，这才有了后来汉武帝纵横捭阖的发挥空间；唐初武则天横空出世，把李唐元老势力重新洗了一次牌，这才有了李隆基的“开元盛”……可见，一个社会、不管用什么方式，只要有胆魄把既得利益集团彻底摧毁一次，往往就能走向空前的繁荣。新中国是幸运的，我们已经走完了这一步，虽然付出了不小的代价，但历史会证明、这一切都是值得的。当然，毛主席时代给我们留下的红利远远不止上面三点。中国这四十多年取得的成就、是亘古未有的，这背后的高瞻远瞩与大慈大悲、是空前绝后的。时代的潮水浩荡向前，红利总有吃完的那一天，种种迹象表明，这一天恐怕不远了。未来的路，得靠我们自己走了！我是大白鹅，如果你认同我的文章，可以给我点个关注哦~么么', 0, '2023-04-14 13:29:36', '1646686871436144642', '2023-04-14 13:29:36', '1646686871436144642', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646749260026253314, '转行自学Java，八个月成功上岸（艰难的自学历程)', '转行学Java，最后找到第一份工作，我一共用了八个月。六个半月学习技术，一个半月找到工作。自学Java到就业并不容易，过程中多次想放弃，学习遇到的问题太多自己解决很麻烦加上网络上各种传达行情不好的信息。现在想来能坚持下来并且成功上岸，很感谢曾经那个坚持的自己。大学是土木专业，毕业后没有从事本专业工作，因为不想一辈子待在工地，每天和水土泥沙打交道，所以从毕业开始一直做销售相关工作，线上线下的都做过，做销售三年多也没有攒下钱，主要还是销售工作太不稳定，加上现在的销售是真的难做，每天和人打交道快要疯掉。转行的时候想了好多方向，最后选择了互联网行业，IT方向，感觉这才是未来的发展趋势，经常在网上看到，穷人家的孩子首选计算机，没有复杂的关系网，最后能达到什么样的高度都是看技术。我选择了学习Java，因为都说Java是市场需求最高的，在软件开发占比70%以上。讲到我学习的过程，还是比较坎坷，在最开始选择Java教程时候，换了好多套才找到适合自己的，有的教程要么是比较老旧，要么是讲的不够细致看的云里雾里。对于一个初学的人来说，选择一套好的教程是非常重要的，如果大家找到适合自己的教程看，可以套，我就是看这套教程学的。点击下面这个插件进群找管理要教程就行，这个群人还挺多的，平时可以再里面交流一下学习心得，问问遇到的问题，会有大佬在里面解答。点击领取2023最新学习教程+PDF书籍然后给大家分享一下我总结出来学Java该注意的一些重点：首先最重要的是转行的决心和毅力，或者说学习的决心和毅力。千万不能因为学习过程中遇到问题很多就退缩，也不要看到网上那些消极情绪传递而放弃。然后就是千万不要觉得视频教程看得懂就以为自己学会了，学Java一定要多去敲代码，增加自己的代码量，锻炼代码思维，提高实际开发能力，不然只是看视频，看十遍都学不会。最后就是不要闭门造车，交流是非常有必要的，这会很大提高学习效率，如果条件允许，身边有程序员朋友可以多请教，如果没有，可以再网上找个私教老师一对一的带着学，学习会变得系统高效。学成之后找工作的时候不太顺利，我包装了两年经验，今年工作是不太好找，竞争挺大的，投了很多简历面试比较少，我面试了几家都是外包公司，薪资不高。刚开始的两周还好，当我一个月都没有找到工作时，一度产生自我怀疑，就在崩溃的边缘，一度以为自半年多的时间浪费了。后来和群友聊起才发现问题，一是我的简历写得有点水，二是不能一键海投，我本以为一件海投之后就结束了，没什么可投的，后来才知道这样会错失很多面试机会，因为很多公司是一件海投投不到的。最好还是多去看，选择合适的公司去投简历，主动和HR去通。需要简历模板，面试题也可以加这个群获取。还有很多开发工具，pdf书籍等Java学习交流心得+资源岗位内后面简历通过群里大佬的指点，皇天不负有心人，找到了工作，薪资待遇还不错，在重庆税前9K*14薪。是自研公司，做新能源充电平台的，规模不大，几十人的团队，加班不多，总体来说还挺好的。最后我想说，不要抱怨市场环境有多不好，想想我的本专业土木，已经被人们说了十几年不行的行业，我的大学同学也有一些做的不错的。选择了一个行业就不要抱怨，抱怨解决不了任何问题，在任何行业里都是一样的道理，只有不断的去提升自己的能力才是解。', 0, '2023-04-14 13:36:33', '1646686871436144642', '2023-04-14 13:36:33', '1646686871436144642', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646843841380106242, 'Java学习步骤及路线（超详细）', '我学习Java 已经快三年了，在 Java 学习这条路上也踩过无数次的坑，恰巧有小伙伴问我 Java 学习的路线，我想着趁这次机会分享自己学 Java 的路线，希望给小伙伴们一点帮助，避开路上的一些坑，一起进大厂。首先，我先分享下自己对不同学习方式的理解，小伙伴们可以根据自己情况选择。看视频系统学习，比如培训机构的课程、MOOC的课程等。看视频的好处就是有老师带着，易于理解和掌握，非常适合初学者。看书学习，如《Redis设计与实现》、《 Java 并发编程的艺术》，便于了解技术脉络和深入学习知识点。看博客和源码精进学习。博客的好处是有些知识点会以很通俗的方式讲解出来，我们很好理解。第一阶段： Java 基础最开始要学习的是 Java 基础，学习了这部分，就会对 Java 语言有一个初步的了解。其实大部分语言的基础知识都是大同小异，如果之前已经学习过其他语言如C、C++，那学习这部分会更快。这部分主要学习的内容有：基本程序结构，类与对象，接口，泛型，反射，集合，异常与调试， Java 网络编程， Java I/O和多线程。学 Java 基础，推荐大家看尚硅谷宋红康老师的 Java 教程，宋老师的课程更适合零基础学员，从 Java 语言起源开始，循序渐进，知识点剖析细致。宋老师的 Java 基础教程：尚硅谷Java零基础入门教程（含百道Java真题，2万多行Java代码实战）_哔哩哔哩_bilibili除此之外，还可以阅读《 Java 核心技术 卷I》，这本书偏向实用，广度和深度都恰到好处。其中，第7-9章讲述了 Java 的GUI编程， Java 的GUI开发使用并不多，这部分可以先跳过。网上也有一些不错的文档教程网站，可以辅助学习：廖雪峰 Java 教程：Java教程 - 廖雪峰的官方网站菜鸟教程 Java ：Java 教程 | 菜鸟教程当学完了这部分，就可以做个图书管理系统、学生管理系统这样的小项目了。还记得库森在大二学完这部分，就跟着教程学做了个贪吃蛇游戏，还是蛮有成就感的。当然，时间有限的小伙伴，可以不用做这块的项目，直接做 Java Web 项目就好了。第二阶段：数据库MySQL 和 Oracle 都是广受企业欢迎的数据库，其中 MySQL 是目前应用最广泛的开源关系数据库，对于新手或者校招的小伙伴，我们目前只学习 MySQL 就可以了。这部分主要学习的内容有：数据库的CRUD操作、JDBC API、数据库特性和数据库连接池。其中，数据库连接池是为了避免频繁地创建和销毁 JDBC 连接，常见连接池包括 C3P0，Druid 和 HikariCP，目前使用最广泛的是HikariCP。尚硅谷的MySQL入门视频：MySQL_基础+高级篇- 数据库 -sql -mysql教程_mysql视频_mysql入门_尚硅谷_哔哩哔哩_bilibili书籍方面，推荐入门的小伙伴看《MySQL必知必会》，是一本小册子，这本书实践性很强，基本没有什么理论的堆砌，非常适合入门。如果想要深入学习，可以看《高性能 MySQL》，这本书是MySQL领域的经典之作，不过就是太厚了，面试重点看索引部分就可以了。除此之外，如果要深入学习MySQL的使用和原理，可以看极客时间的专栏《MySQL实战45讲》，阿里资深技术专家讲解的课程，有很多生产经常遇到的问题，非常有深度。第三阶段： Java Web学习 Java Web，我们不仅需要掌握后端 Java 技术，还需要学习些前端知识。前端有三大基础技术 Html、CSS和 Java Script，初学的话，学习这些就可以了。如果想做出更好的交互式效果，可以再学习Vue和React等前端技术。后端 Java 技术包括 Servlet、Filter、Listener、Session、Cookie、JSP、EL 表达式和 JSTL 等。其中，像 JSP 这样比较老的技术，目前在各大互联网公司基本不再使用，已经被 Freemark、Thymeleaf 这样的模板引擎所替代，我们只需要了解基本使用即可。入门 Java Web，推荐尚硅谷的 Java Web 教程，教程不仅包括前端三大技术，还有后端 Java 技术，最后还会带大家做一个书城项目。Java Web教程：尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版_哔哩哔哩_bilibili第四阶段：主流框架这部分我们要学习的主流框架主要有 Spring、Spring MVC 和 MyBatis，俗称 SSM 框架。曾经的 SSH 框架，即 Struts2、Spring、Hibernate 框架，已经逐渐被 SSM 替代，现在可以不用再学 Struts2 和 Hibernate 框架了。学习这些框架之前，我们先来学习项目管理利器Maven和Git。MavenMaven 是一个项目管理工具，它基于项目对象模型(POM)的概念，它可以管理项目的构建、报告和文档。Maven 本质就是一个巨大的 jar 包资源库，使用 Maven 构建项目，只需在项目的 pom.xml 中配置相关依赖后，就可以直接从远程仓库同步到本地，再也不用满世界搜索下载 jar 包了，省了很多查找和下载的烦恼。动力结点的Maven实战入门视频：2020最新Maven教程-Maven基础篇之Maven实战入门_哔哩哔哩_bilibiliGitGit 是一个开源的分布式版本控制系统，最大作用就是对文件进行版本管理，方便在不同版本进行切换修改，还可以很方便的协作开发。GitHub 是基于 Git 的代码库托管站，学会了 Git ，我们就能愉快地上 Github 交友了。狂神说的 Git 视频： 【狂神说Java】Git最新教程通俗易懂_哔哩哔哩_bilibil喜欢文字版的小伙伴，推荐看廖雪峰的 Git 教程，很浅显易懂廖雪峰的 Git 教程：Git教程 - 廖雪峰的官方网站方便查阅的 Git 中文手册：Git - BookSSM框架Spring 是一个轻量级的 Java 开发框架，现在已经是最受欢迎的企业级 Java 应用程序开发框架，目前已经更新到 Spring5。Spring 框架的核心特性是依赖注入(DI)与面向切面编程(AOP)，Spring 框架的组成结构图如下所示：Spring MVC 是一个基于MVC架构，用来简化web应用程序开发的框架，它是 Spring 的一部分，SpringMVC 已经成为目前最主流的 MVC 框架之一。MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。在使用传统JDBC时，往往需要写很多JDBC代码，需要自己写SQL语句以及自己装配参数，然后自己对结果集进行封装处理。而Mybatis则帮我们简化了以上功能，只需要一些配置文件（xml）或是注解即可完成对数据库的查询以及结果的映射封装。学习SSM框架，推荐使用一整套课程进行学习，会有更好的连贯性，而且还会学习整合SSM框架。SSM框架视频：2020最新（idea版）SSM框架全套教程-spring-springmvc-mybatis_哔哩哔哩_bilibili整合SSM框架还是比较繁琐的，库森之前学习时就整合了一天，时间紧张的小伙伴可以不用在整合这里花费时间，因为这种整合方式目前也不在流行了，现在直接使用更强大的利器Spring Boot就可以了。Spring BootSpring Boot 采用约定大约配置的方式，大量的减少了配置文件的使用，从而使开发人员不再需要定义样板化的配置。学习 Spring Boot，推荐雷丰阳老师的 Spring Boot 课程，课程基于 SpringBoot2.3与2.4 版本，包含核心基础、Web原理、单元测试、数据访问、指标监控等章节。那要不要跳过了 SSM 直接去学习 Spring Boot呢？如果只是为了使用 Spring Boot，当然可以跳过，毕竟 SSM 配置太繁琐了。如果想深入学习，尤其是找 Java 开发的工作，面试中会出现很多 Spring 的底层问题，因此还是要学习 SSM 的，如果跳过了不利于学习原理。雷老师的 Spring Boot 课程：尚硅谷雷神SpringBoot2零基础入门springboot全套完整版（spring boot2）_哔哩哔哩_bilibili第五阶段：服务器中间件学完上面的内容，我们已经具备实际项目的开发能力了，但是要解决些复杂的业务场景，我们还要学习Redis、MQ、Elasticsearch这些中间件。RedisRedis 是一个 key-value 存储系统，是跨平台的非关系型数据库，可用作数据库，高速缓存和消息队列代理。Redis作为当下主流的缓存技术，已经成为互联网企业的不二首选。Redis入门到精通课程：黑马程序员Redis入门到精通，Java企业级解决方案必看_哔哩哔哩_bilibili想深入学习的小伙伴，推荐阅读《Redis设计与实现》，知识点非常丰富，讲了很多底层的原理，我曾经看了三遍，对我面试帮助很大，非常推荐！Redis 设计与实现在线版：Redis 设计与实现 — Redis 设计与实现查询Redis命令的中文网站：Redis中文教程MQMQ（Message Queue）是一种跨进程的通信机制，用于传递消息。通俗点说，就是一个先进先出的数据结构。MQ有三大主要作用分别为解耦、异步、削峰/限流。目前业界有很多MQ产品，比较出名的有以下四种：我最开始学习的是Kafka，因为做的项目中使用到了，小伙伴们根据喜好或者项目需要，选择一款MQ学习就可以了。Kafka 教程：尚硅谷Kafka教程(消息队列kafka快速入门)_哔哩哔哩_bilibiliRabbitMQ教程：【涛哥】最适合小白入门的RabbitMQ教程_哔哩哔哩_bilibili此外，如果要深入学习，可以阅读《Kafka权威指南》，这本书由Kafka作者执笔，覆盖比较全面。Elasticsearch全文搜索属于最常见的需求，开源的 Elasticsearch是目前全文搜索引擎的首选。它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。Elasticsearch的底层是开源库 Lucene。但是，必须自己写代码去调用Lucene的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。ElasticSearch7.6.x最新完整教程：【狂神说Java】ElasticSearch7.6.x最新完整教程通俗易懂_哔哩哔哩_bilibili项目实践学完了这些，就可以把这些技术整合起来做个项目，这里推荐个我做过的社区论坛项目。这个论坛项目不仅实现了基本的注册，登录，发帖，评论，点赞，回复功能，同时使用前缀树实现敏感词过滤，使用wkhtmltopdf生成长图和pdf，实现网站UV和DAU统计，并将用户头像等信息存于七牛云服务器。这是项目使用到的相关技术：这个项目作为Spring Boot实战练手很不错，老师讲解的很清晰，课程的深度和广度都有，而且课程最后还会手把手教大家将项目部署在云服务器。课程中也会简要讲解Redis、Kafka和Elasticsearch，即使没有学过这些技术，仍然可以学习这个项目。社区论坛项目：视频去哪了呢？_哔哩哔哩_bilibili补充一点，现在的服务器基本都是Linux系统，将项目部署在服务器，学习些基本的Linux命令是必不可少的。韩顺平 一周学会Linux视频：【小白入门 通俗易懂】2021韩顺平 一周学会Linux_哔哩哔哩_bilibiliLinux命令在线查询：Linux命令搜索引擎 命令，Linux Linux命令搜索引擎 命令详解：最专业的Linux命令大全，内容包含Linux命令手册、详解、学习，值得收藏的Linux命令速查手册。 - Linux 命令搜索引擎第六阶段：微服务和分布对于实习和校招的小伙伴来讲，学好前五阶段的技术知识，再深入学习个技术点就可以了，如果还有时间和精力的小伙伴，可以学习微服务和分布式的内容。Spring CloudSpring Cloud 是一套完整的微服务解决方案，基于 Spring Boot框架。准确的说，Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性简化了分布式系统的开发，比如服务发现、服务网关、服务路由、链路追踪等。SpringCloud(H版&alibaba)框架开发教程：尚硅谷SpringCloud框架开发教程(SpringCloudAlibaba微服务分布式架构丨Spring Cloud)_哔哩哔哩_bilibiliDubbo值得一提的是，还有阿里开源Dubbo，Dubbo一个高性能优秀的服务框架。简单地说，Dubbo是一个基于Spring的RPC（远程过程调用）框架，能够实现服务的远程调用、服务的治理。至于Spring Cloud 和Dubbo 有什么区别，大家可以搜索下。这里用网络上一个台式电脑的比喻来说就是：Dubbo 是品牌机，Spring Cloud 是组装机。Dubbo 视频：Dubbo教程_雷丰阳_尚硅谷_哔哩哔哩_bilibiliZooKeeperZooKeeper是一个高可用的分布式管理与协调框架，基于ZAB算法（原子消息广播协议）的实现。该框架能够保证分布式环境中数据的一致性，使得ZooKeeper成为了解决分布式一致性问题的利器。zookeeper视频：黑马程序员Java高薪必备教程，分布式技术ZooKeeper深入浅出_哔哩哔哩_bilibili第七阶段：进阶优化学会前面这些，我们就可以独立完成一个小项目，独立完成项目组分配给你的开发任务。但是这还不足以写出好的代码，我们要想写出好的代码，还需要学习设计模式，学习多线程，以及JVM的内部原理等。同样，这些也是面试的必考点。设计模式的书籍推荐《HeadFirst设计模式》，这是一本图文并茂的书籍，适合入门。JVM 的书籍推荐《深入理解 Java 虚拟机》，这本书是 Java 开发者必看的书，很多 JVM 的文章都是来自这本书。Java 并发方面，可以看《 Java 并发编程的艺术》，这本书深入到JVM、CPU层面讲解了 Java 并发框架、线程池的原理等，面对面试足够了；还有《并发编程实战》，这是一本不错的 Java 并发参考手册。', 0, '2023-04-14 19:52:23', '1646127543398469633', '2023-04-14 19:52:23', '1646127543398469633', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646844211426770945, 'Java基础知识大全(一）', '一、基础知识：1、JVM、JRE和JDK的区别：JVM(Java Virtual Machine):java虚拟机，用于保证java的跨平台的特性。java语言是跨平台，jvm不是跨平台的。JRE(Java Runtime Environment):java的运行环境,包括jvm+java的核心类库。JDK(Java Development Kit):java的开发工具,包括jre+开发工具2、环境变量path和classpath的作用是什么？(1)path是配置Windows可执行文件的搜索路径，即扩展名为.exe的程序文件所在的目录，用于指定DOS窗口命令的路径。(2)Classpath是配置class文件所在的目录，用于指定类搜索路径，JVM就是通过它来寻找该类的class类文件的。3、变量有什么用？为什么要定义变量？什么时候用？答：变量的作用：用来存储数据。为什么要定义变量：用来不断的存放同一类型的常量，并可以重复使用4、&和&&的区别?答：（1）&&会出现短路，如果可以通过第一个表达式判断出整个表达式的结果，则不继续后面表达式的运算；只能操作boolean类型数据；（2）&不会出现短路，将整个表达式都运算。既可以操作boolean数据还可以操作数。5、标示符命名规则：由数字(0-9)，大小写英文字母，以及_和$组成。不能以数字开头。不能使用关键字来自定义命名。6、数据类型：(1)基本数据类型(4类8种)：整数类型：byte、short、int、long浮点数类型：float、double字符类型：char布尔类型：boolean(ture false)(2)引用数据类型：类接口数组7、类型转换精度从高到低 double float long int short(char) byte(1)自动类型转换 将一个低精度—高精度(2)强制类型转换 将一个高精度—低精度(精度会下降)8、java语言的三种技术架构J2EE：企业版是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发。J2SE：标准版是为开发普通桌面和商务应用程序提供的解决方案。该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发。比如Java版的扫雷。J2ME：小型版是为开发电子消费产品和嵌入式设备提供的解决方案。该技术体系主要应用于小型电子消费类产品，如手机中的应用程序等。9、java的跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。跨平台的原因：只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。10、有符号数据的表示法(次重点)原码，反码(原码取反)，补码(反码+1)。11、函数定义：函数就是定义在类中的具有特定功能的一段独立小程序。特点：定义函数可以将功能代码进行封装便于对该功能进行复用函数只有被调用才会被执行函数的出现提高了代码的复用性对于函数没有具体返回值的情况，返回值类型用关键字void表示，那么该函数中的return语句如果在最后一行可以省略不写。函数的应用两个明确：明确要定义的功能最后的结果是什么？明确在定义该功能的过程中，是否需要未知内容参与运算12、重载：概念：在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。特点：与返回值类型无关，只看参数列表(参数类型以及参数个数)。好处：方便于阅读，优化了程序设计。13、数组：概念：同一种数据类型的集合。好处：可以自动给数组中的元素从0开始编号，方便操作这些元素。14、内存结构：栈内存：用于存储局部变量，当数据使用完，所占空间会自动释放。堆内存：数组和对象，通过new建立的实例都存放在堆内存中。方法区：静态成员、构造函数、常量池、线程池本地方法区：window系统占用寄存器：二、面向对象1、面向对象思想：(1)概述：面向对象是相对于面向过程而言的，面向过程强调的是功能，面向对象强调的是将功能封装进对象，强调具备功能的对象；(2)思想特点：A:是符合人们思考习惯的一种思想；B:将复杂的事情简单化了；C:将程序员从执行者变成了指挥者；比如我要达到某种结果，我就寻找能帮我达到该结果的功能的对象，如我要洗衣服我就买洗衣机，至于怎么洗我不管。(3)特征：封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式继承: 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多态: 一个对象在程序不同运行时刻代表的多种状态，父类或者接口的引用指向子类对象2、类和对象：类：对现实世界中某类事物的描述,是抽象的，概念上的定义。对象：事物具体存在的个体。3：成员变量和局部变量的区别(重点)(1)作用域成员变量：针对整个类有效。局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)(2)存储位置成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。(3)初始值成员变量：有默认初始值。局部变量：没有默认初始值，使用前必须赋值。4、匿名对象(1)匿名对象就是没有名字的对象。是对象的一种简写形式。(2)应用场景A:只调用一次类中的方法。B:可以作为实际参数在方法传递中使用5、封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式；比如电脑机箱、笔记本等好处：将变化隔离；方便使用；提高复用性；提高安全性6、关键字private：封装在代码中的体现(1)私有的意思，权限修饰符(2)用来修饰成员变量和成员函数(3)用private修饰的成员只在本类中有效(4)私有是封装的一种体现7、构造方法：(1)特点：方法名与类名相同没有返回类型没有返回值(2)作用：构造函数是用于创建对象，并对其进行初始化赋值，对象一建立就自动调用相对应的构造函数，(3)构造方法的注意事项:A:如果一个自定义类没有构造方法，系统会默认给出一个无参构造方法。B:如果一个自定义类提供了构造方法，那么，系统将不再给出无参构造方法。这个时候，你可以不使用无参构造方法。如果你想使用，那么，就必须手动给出无参构造方法。建议：一般情况下，我们的自定义类都要手动给出无参构造方法。(4)构造方法和成员方法的区别A:格式区别构造方法和类名相同，并且没有返回类型，也没有返回值。普通成员方法可以任意起名，必须有返回类型，可以没有返回值。B:作用区别构造方法用于创建对象，并进行初始化值。普通成员方法是用于完成特定功能的。C:调用区别构造方法是在创建对象时被调用的，一个对象建立，只调用一次相应构造函数普通成员方法是由创建好的对象调用，可以调用多次8、构造代码块：(1)作用：给对象进行初始化，对象一建立就执行，而且优先于构造函数执行(2)构造代码块和构造函数的区别：构造代码块是给所有不同对象的共性进行统一初始化构造函数是给对应的对象进行初始化9、this关键字(1)this关键字代表本类对象的一个引用，谁调用this所在的方法，this就代表谁(2)this的使用场景A:用于区分同名成员变量和局部变量；B:在定义函数时，该函数内部要用到调用该函数的对象时，因为此时对象还没建立，故this代表此对象B:构造函数间调用**这个时候，this(参数)必须作为第一条语句存在。10、Person p = new Person();在内存中做了哪些事情。(1)将Person.class文件加载进内存中。(2)如果p定义在主方法中，那么，就会在栈空间开辟一个变量空间p。(3)在堆内存给对象分配空间。(4)对对象中的成员进行默认初始化。(5)对对象中的成员进行显示初始化。(6)调用构造代码块对对象进行初始化。(如果没有就不执行)(7)调用构造方法对对象进行初始化。对象初始化完毕。(8)将对象的内存地址赋值给p变量，让p变量指向该对象。11、static关键字：(1)静态的意思，用来修饰成员变量和成员函数(2)静态的特点:随着类的加载而加载优先于对象存在对所有对象共享可以被类名直接调用(3)静态的注意事项A:静态方法只能访问静态成员为什么：因为静态的内容是随着类的加载而加载，它是先进内存的。B:静态方法中不能使用this,super关键字C:主方法是静态的public static void main(String[] args)public:公共的意思，是最大权限修饰符。static:由于jvm调用main方法的时候，没有创建对象。只能通过类名调用。所以，main必须用static修饰。void:由于main方法是被jvm调用，不需要返回值。用void修饰。main:main是主要的意思，所以jvm采用了这个名字。是程序的入口。String[]:字符串数组args:数组名在运行的时候，通过java命令给args数组赋值。格式：java MainTest hello world itcast(4)静态变量和成员变量的区别A：调用方式静态变量也称为类变量，可以直接通过类名调用。也可以通过对象名调用。这个变量属于类。成员变量也称为实例变量，只能通过对象名调用。这个变量属于对象。B：存储位置静态变量存储在方法区长中的静态区。成员变量存储在堆内存。C：生命周期静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。成员变量随着对象的创建而存在，随着对象的消失而消失。D：与对象的相关性静态变量是所有对象共享的数据。成员变量是每个对象所特有的数据。(5)静态的优点和弊端优点：对对象的共享数据进行单独空间的存储，节省内存，没有必要每个对象都存储一份可直接被类名调用弊端：生命周期过长，随着类的消失而消失访问出现权限，即静态虽好但只能访问静态(6)什么使用使用静态呢？A:当所有对象共享某个数据的时候，就把这个成员变量定义为静态修饰的。B:当某个方法没有访问该类中的非静态成员，就可以把这个方法定义为静态修饰。静态的生命周期比较长，所以一般不推荐使用。(7)静态代码块A:它只执行一次，它比main还先执行。B:执行顺序静态代码块–构造代码块–构造方法12、制作API(次重点)API(全拼):Application Program Interface 应用程序编程接口。(1)类中的内容需要用文档注释。(2)使用JDKin目录下的javadoc工具。格式:javadoc -d 目录 -author -version ArrayTool.java13、单例设计模式：(1)设计模式：解决某类问题行之有效的方法，是一种思想，是规律的总结(2)用来保证某个类在内存中只有一个对象(3)保证唯一性的思想及步骤**为了避免其他程序建立该类对象，先禁止其他程序建立该类对象，即将构造函数私有**为了其他程序访问到该类对象，须在本类中创建一个该类私有对**为了方便其他程序访问到该类对象，可对外提供一个公共访问方式比如API中的Runtime类就是单例设计模式。', 0, '2023-04-14 19:53:52', '1646684626040664065', '2023-04-14 19:53:52', '1646684626040664065', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646844546065121282, '转行自学Java，八个月成功上岸（艰难的自学历程)', '转行学Java，最后找到第一份工作，我一共用了八个月。六个半月学习技术，一个半月找到工作。自学Java到就业并不容易，过程中多次想放弃，学习遇到的问题太多自己解决很麻烦加上网络上各种传达行情不好的信息。现在想来能坚持下来并且成功上岸，很感谢曾经那个坚持的自己。大学是土木专业，毕业后没有从事本专业工作，因为不想一辈子待在工地，每天和水土泥沙打交道，所以从毕业开始一直做销售相关工作，线上线下的都做过，做销售三年多也没有攒下钱，主要还是销售工作太不稳定，加上现在的销售是真的难做，每天和人打交道快要疯掉。转行的时候想了好多方向，最后选择了互联网行业，IT方向，感觉这才是未来的发展趋势，经常在网上看到，穷人家的孩子首选计算机，没有复杂的关系网，最后能达到什么样的高度都是看技术。我选择了学习Java，因为都说Java是市场需求最高的，在软件开发占比70%以上。讲到我学习的过程，还是比较坎坷，在最开始选择Java教程时候，换了好多套才找到适合自己的，有的教程要么是比较老旧，要么是讲的不够细致看的云里雾里。对于一个初学的人来说，选择一套好的教程是非常重要的，如果大家找到适合自己的教程看，可以套，我就是看这套教程学的。点击下面这个插件进群找管理要教程就行，这个群人还挺多的，平时可以再里面交流一下学习心得，问问遇到的问题，会有大佬在里面解答。点击领取2023最新学习教程+PDF书籍然后给大家分享一下我总结出来学Java该注意的一些重点：首先最重要的是转行的决心和毅力，或者说学习的决心和毅力。千万不能因为学习过程中遇到问题很多就退缩，也不要看到网上那些消极情绪传递而放弃。然后就是千万不要觉得视频教程看得懂就以为自己学会了，学Java一定要多去敲代码，增加自己的代码量，锻炼代码思维，提高实际开发能力，不然只是看视频，看十遍都学不会。最后就是不要闭门造车，交流是非常有必要的，这会很大提高学习效率，如果条件允许，身边有程序员朋友可以多请教，如果没有，可以再网上找个私教老师一对一的带着学，学习会变得系统高效。学成之后找工作的时候不太顺利，我包装了两年经验，今年工作是不太好找，竞争挺大的，投了很多简历面试比较少，我面试了几家都是外包公司，薪资不高。刚开始的两周还好，当我一个月都没有找到工作时，一度产生自我怀疑，就在崩溃的边缘，一度以为自半年多的时间浪费了。后来和群友聊起才发现问题，一是我的简历写得有点水，二是不能一键海投，我本以为一件海投之后就结束了，没什么可投的，后来才知道这样会错失很多面试机会，因为很多公司是一件海投投不到的。最好还是多去看，选择合适的公司去投简历，主动和HR去通。需要简历模板，面试题也可以加这个群获取。还有很多开发工具，pdf书籍等Java学习交流心得+资源岗位内后面简历通过群里大佬的指点，皇天不负有心人，找到了工作，薪资待遇还不错，在重庆税前9K*14薪。是自研公司，做新能源充电平台的，规模不大，几十人的团队，加班不多，总体来说还挺好的。最后我想说，不要抱怨市场环境有多不好，想想我的本专业土木，已经被人们说了十几年不行的行业，我的大学同学也有一些做的不错的。选择了一个行业就不要抱怨，抱怨解决不了任何问题，在任何行业里都是一样的道理，只有不断的去提升自己的能力才是解。', 0, '2023-04-14 19:55:11', '1646686871436144642', '2023-04-14 19:55:11', '1646686871436144642', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646844942946942978, 'Java程序员必看的 13 本 Java 书籍！', '关乎于程序员，除了做项目来提高自身的技术，还有一种提升自己的专业技能就是：多！看！书！毕竟，书是学习的海洋呢！So，Java程序员你们准备好了吗？双手奉上Java程序员必读之热门书单。在下面这 13 本书籍中小编还是要建议大家可以先去关注英文原版，毕竟翻译的书籍中都有一定的语法错误。动图封面入门《Head First Java》作者： Kathy Sierra / Bert Bates简介：《Head First Java》是一本完整地面向对象(object-oriented，OO)程序设计和Java的学习指导用书，根据学习理论所设计，你可以从程序语言的基础开始，到线程、网络与分布式程序等项目。重要的是，你可以学会如何像一个面向对象开发者一去思考，而且不只是读死书。作为一本入门书，它是绝对出色的。一个星期就能让你明白怎么用Java写程序了。尤其是你有其它语言基础的情况下，这本书能迅速让你明白java的特质。 缺点是，它真的只是入门书。你必然还需要一本Java大字典，比如《Thinking in Java》，以便查Java在细节上的更多东西。关于这一点，书中附录B也说得很清楚了。《Java 核心技术：卷1 基础知识作者：Cay S. Horstmann / Gary Cornell 译者： 杜永萍 / 邝劲筠 / 叶乃文简介：《JAVA核心技术(卷1):基础知识(原书第8版)》是《Java核心技术》的最新版，它反遇了Java SE6的新特性。全书共14章，包括Java基本的程序结构、对象与类、继承、接口与内部类、图形程序设计、事件处理、Swing用户界面组件、部署应用程序和Applet、异常日志断言和调试、叙述方式深入浅出，并包含大量示例，从而帮助读者充分理解Java语言以及Java类型库的相关特性。作为一本入门参考书，绝对比国内现在的大部分教材要优秀得多。对于Java初学者来说，也是一本值得时常翻阅的技术手册。书中有较多地方进行java与c++的比较，这是很有意义的，因为java与c++其实有很多类似之处，尤其是在面向对象的方面。同时书中对Java与C++不同的地方做了一些解释，这对于学习过C++的朋友来说是很有助《Java 编程思想》(英文名《Thinking In Java 》)作者: [美] Bruce Eckel 译者: 陈昊鹏 / 饶若楠简介：本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性(深入的面向对象概念、多线程、自动项目构建、单元测试和调试等)，本书都能逐步指你轻松掌握。搞JAVA不多，但是因为很多好书都以JAVA为实例代码，所以也自学的JAVA，这本书我利用十一的假期，完整的看了一遍，虽然都很基础，但是对内力有绝对的提升《Java开发实战经典》作者：李兴华 编著简介：本书是一本综合讲解Java核心技术的书籍，在书中使用大量的代码及案例进行知识点的分析与运用，并且给出一些比较成熟的开发步骤，帮助读者更好地进行Java的开发。从作者多年的Java培训经验来看，大部分学生对各种高端开发都没有任何问题，唯的问题在于Java基础并不牢固，而且在国内也始终没有一本真正可以引领读者入门的好书籍，大部分的书籍都是围绕概念本身进行讲解的，没有讲解清楚为什么要具备这些知识以及该如何去理解这些知识。不知道我应该带着怎样的心情来写这份书评…… 首先java是一门高级语言，不是那么容易吸收和理解的，这就是这本书那么厚的原因吗? 好吧……书中很多都是废话，我一般都是跳着看，只看“注意”和字体加深的部分，以及实例代码。 相比书，光盘里的视频讲解较实用进阶《Effective Java》作者：(美)Joshua Bloch 译者：潘爱民简介：本书介绍了在Java编程中57条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮的高效的代码看这本书的朋友就如作者所说，如果你没一定java经验的话先不要看了，因为看了可能没多少的帮助，或者很快就会遗忘千万也不要急功近利。总而言之，经典之作，当然了，有条件的朋友希望直接看英文版好了。《Spring揭秘》作者：王福强简介：没有教程似的训导，更多的是说故事般的娓娓道来，本书是作者在多年的工作中积累的第一手Spring框架使用经验的总结，深入剖析了Spring框架各个模块的功能、出现的背景、设计理念和设计原理，揭开了Spring框架的神秘面纱，使你“知其然，更知其所以然”。每部分的扩展篇帮助读者活学活用Spring框架的方方面面，同时可以触类旁通，衍生出新的思路和解决方案。本书内容全面，论述深刻入理，必将成为每个Java专业开发人员必备的Spring图书。好书，Spring里实践了大量Java语言优秀的理念，此书通过讲解Spring原理，通俗易懂地向我们展示了这些理念。《分布式 Java 应用：基础与实践》作者：林昊简介：本书介绍了编写分布式Java应用涉及的众多知识点，分为了基于Java实现网络通信、RPC;基于SOA实现大型分布式Java应用；编写高性能Java应用;构建高可用、可伸缩的系统四个部分，七章内容来进行介绍，在这一本不算厚的书中，一方面结合作者的验介绍了这些知识点；另一方面提供了进一步学习这些知识点的参考资料，希望能给想掌握编写分布式Java应用知识点的开发人员提供一定的帮助以及指引，同时也希望书中分享的经验对于目前正在从事分布式Java应用编写的开发人员提供帮助。之前刚刚读了《大型网站架构技术》，算是同一个大主题，但前者主要讲网站机构的理论和最佳实践，而这本书则实践性比较强，还涉及了java网络编程，并行编程，jvm性能调优等等，每个方面都值得深入研究。《http权威指南》作者：David Gourley / Brian Totty 译者：陈涓 / 赵振平简介：超文本传输协议(Hypertext Transfer Protocol，HTTP)是在万维网上进行通信时所使用的协议方案。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。HTTP起初是一个简单的协议，因此你可能会认为关于这个协议没有太多好说的。但现在，你手上拿着的是却一本两磅重的书。如果你对我们怎么会写出一本650页 的关于HTTP的书感到奇怪的话，可以去看一下目录。本书不仅仅是一本HTTP首部的参考手册;它是一本名副其实的web结构圣经。本书对一些常见的误解进行了说明，推荐了“各种使用诀窍”，提供了便捷的参考资料，并且对枯燥且令人费解的标准规范进行了可读性很强的介绍。在这本书里，我们对Web正常工作所必须且互相关联的技术进行了详细的介绍。但是内容比较老，全而浅，不过用给我镂空纱一样的HTTP知识查漏补缺足够了，大部分章节翻译的还不错。《深入理解 Java 虚拟机》作者：周志明简介：作为一位Java程序员，你是否也曾经想深入理解Java虚拟机，但是却被它的复杂和深奥拒之门外?没关系，本书极尽化繁为简之妙，能带领你在轻松中领略Java虚拟机的奥秘。本书是近年来国内出版的唯一一本与Java虚拟机相关的专著，也是唯一一本同从核心理论和实际运用这两个角度去探讨Java虚拟机的著作，不仅理论分析得透彻，而且书中包含的典型案例和最佳实践也极具现实指导意义。在国内的图书市场上来看，这是一本很优秀的介绍 Java 虚拟机的书籍。读起来很引人入胜，一口气看几章，不费劲。我对本书最大的感受就是：全面。作为一个刚开始接触 JVM 的人，我感觉本书基本上把 JVM 中所涉及的概念涵盖到。Java四大名著《Java编程思想(第4版)》原书名：Thinking in Java《JAVA 2核心技术 卷II：高级特性(原书第7版)》本书是java 2技术权威指南，全面覆盖java 2技术的高级主题，包括：多线程、集合框架、网络api、数据库编程、分布式对象等，深入探究了swing、java 2d api、javabean、java安全模式、xml、注释、元数据等主题，同时涉及本地方法、国际化以jdk 5.0的内容。本书适合软件开发人员、高等院校学生和教师参考。《Java Web开发详解--XML+XSLT+Servlet+JSP深入剖析与实例应用本书共分4部分，从xml、servlet、jsp和应用的角度向读者展示了java web开发中各种技术的应用，循序渐进地引导读者快速掌握java web开发。本书内容全面，涵盖了从事java web开发所应掌握的所有知识。在知识的讲解上，本书采用理论与实践相结合的方式，从程序运行的内部机制进行分析讲解，并通过大量的实例和实验来验证并运用本书的知识。本书语言生动、通俗易懂、讲解细致，大部分章节都提供了多个例子，而且很多例子都是目前web开发中经常使用的功能，具有相当的实用价值。本书不仅可以作为java web开发的学习用书，还可以作为从事java web开发的程序员的参考用书和必备手册《Effective Java中文版(第2版)》本书介绍了在java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。', 0, '2023-04-14 19:56:46', '1646127543398469633', '2023-04-14 19:56:46', '1646127543398469633', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646846221270138882, 'OOP编程思想：封装、继承、多态', '面向对象编程（Object-Oriented Programming）与面向过程（Procedure Oriented ）两种方法都是编程中的比较常用的方法，从理论上来说，都能达到用计算机程序来解决实际问题的目的， 只不过是其中所体现出来的思想不一样而已。面向过程：面向过程的思想是把一个项目、一件事情按照一定的顺序，从头到尾一步一步地做下去，先做什么，后做什么，一直到结束。这种思想比较好理解，其实这也是一个人做事的方法。面向对象：面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。这种思想比较适合多人的分工合作，就像一个大的机关，分成各个部门，每个部门分别负责某样职能，各个部门可以充分发挥自己的特色，只要符合一定前提就行了面向对象（OOP）的三个特征：封装（Encapsulation）继承（Inheritance）多态（Polymorphism）一、封装1、定义： Java中的封装是一种将数据(变量)和作用于数据(方法)的代码打包为一个单元的机制。在封装中，类的变量将对其他类隐藏，并且只通过当前类的方法访问。Encapsulation can change the internal structure of a class without affecting the overall structure, while protecting the data. For the outside world, its interior is hidden, and what is exposed to the outside world is only the methods that can access it. 封装可以对类的内部进行改变而不影响整体结构，同时也保护来数据。对于外界而言，它的内部是隐藏的，暴露给外界的只是可以访问它的方法。2、优点：类内部可以自由修改可以对成员变量更准确的控隐藏信息，保护数据降低耦合度3、Java的访问控制级别（1）public：对外公开，级别最高。（2）protect：只对同一个包中的类或子类公开，级别次之。（3）默认：只对同一个包中的类公开（4）private:不对外公开，只能在对象内部访问，级别最低。二、继承public class C extends A...}1、使用extends关键字。继承允许class继承另一个class的一些通用的fields和methods。多个类存在相同的属性和行为时，定义这么多个类的属性和行为属实有些麻烦，将他们放到单独一个类中就相对比较简洁，只需继承那个定义好属性和行为那个类可。super class ：父类。是哪个可以被别人继承自己的属性的class。sub class ：子类。是继承另一个class的属性的class。子类也可以添加自己的fields和methods，也可以覆盖重写（override）父类的方法（不影响父类）。2、作用：继承提高了代码的重复继承的出现让类与类之间产生了关系，为多太提供了条件。3、Java只支持单继承，不允许多继承，即一个子类只能有一个父类，而父类可以有多个子类。重载（overloadpublic class Overloading 重载方法满足的一些条件：（1）方法名相同。（2）方法的参数类型、个数、顺序至少有一项不同。（3）方法的返回值可以不同。（4）方法的修饰符可以不同。方法重写/覆盖（override）：覆盖（override）的一些规则：method只能在子类里面继承，不能在同一个class里面。子类参数和父类参数一定要一模一样。谁都不能是谁的subclass子类的返回类型要和父类的返回类型一样，或者是父类的返回类型的子类。access level 只能越来越大。如果父类是public的，子类只能是public的。如果父类是protected，那子类只能是protected或者public。private的方法不能被override。一个加了final的method不能被override。一个加了static的method也不能被overrride。但是可以被重新定义。因为static是class level的。跟子类object没关系。如果子类和父类在同一个包里，子类可以overrride父类的不是private和final的方法。如果子类和父类不在同一个包里，那子类只可以overrride父类public 或者 protected的非final方法。子类可以随意抛出uncheck exceptions，不管父类有没有抛出异常。对于checked exception， 子类抛出的异常需要是父类抛出异常的孩子，或者是抛出比父类少的异常。（narrower or fewer）Constructor 不能被 overridde.重载（overload）与覆盖（override）的区总结：(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。三、多态1、多态是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。2、在Java中有两种体现：方法重载（overload）和覆盖（override）。对象的多态性——可以直接应用在抽象类和接口上。3、多态存在的三个前提：要有继承关系子类要重写父类的方法父类引用指向子类对象4、当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。5、多态的定义与使用格式定义格式：父类类型 变量名=new 子类类型();多态成员的特点：（1）多态成员方法：编译看左边，运行看右边Fu f1=new Zi();System.out.println(f1.show());             //f1的门面类型是Fu,但实际类型是Zi,所以调用的是重写后的方法6、instanceof关键字x instanceof A :检验x是否为类A的对象，返回值为boolean型。要求x所属的类与类A必须是子类和父类的关系，否则编译错误。如果x属于类A的子类B，x instanceof A值也为true。多态案例：', 0, '2023-04-14 20:01:51', '1646684626040664065', '2023-04-14 20:01:51', '1646684626040664065', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');
INSERT INTO `text` VALUES (1646846797584285697, 'JAVA并发编程知识总结（全是干货超详细）', '前言本篇基于拉勾课程总结了并发编程相关知识，比如各种锁、线程池、JUC工具包等等，超详细，希望对大家有所帮助。一、多线程并发编程基础基础知识Java是支持多线程的开发语言，意思就是可以在多CPU核心的机子上同时处理不同的任务，优化资源的使用率，提升程序的效率。1） 并发编程三要素：原子性：一个或者多个操作要么全部执行成功要么全部执行失败。有序性：程序执行顺序按照代码顺序先后执行，但是CPU可能会对指令进行重排序。可见性：当多个线程访问同一个变量时，如果一个线程修改了变量，其他线程立即获取最新的值。2） 线程的五大状态：创建状态：当用new操作符创建一个线程的时候。就绪状态：调用start方法，处于就绪状态的线程并不一定马上就执行run方法，还需要等待CPU的调度。运行状态：CPU开始调度线程，并开始执行Run方法阻塞状态：线程的执行过程中可能因为一些原因进入阻塞状态，比如调用sleep方法，获取尝试得到一个锁等等。、死亡状态：Run方法执行完或者执行中遇到异常。3） 悲观锁和乐观锁悲观锁：认为一定会有其他线程来改变他，所以每次操作就会加锁，会造成线程阻塞。乐观锁：认为不会有线程来改变他，每次操作不会加锁，但是如果因为其他线程来改变了值，造成了冲突，会因为冲突而操作失败，但是他又会继续重试，直到成功为止，不会造成线程阻塞。4） 线程之间的协作线程之间的协作有：wait、notify、notifyAll等5） Synchronized关键字（同步锁）修饰一个代码块：被修饰的代码块称为同步语句块，作用范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象。修饰一个方法：被修饰的方法称为同步方法，作用范围是整个方法，作用的对象是调用这个方法的对象。修饰一个静态的方法：作用范围是整个静态方法，所用的对象是这个类中的所有对象。修饰一个类：作用范围是synchronized后面括起来的部分，作用的对象是这个类中的所有对象6） CAS比较替换，是实现并发应用的一种技术，主要用于不想使线程进入阻塞的一种方式，操作包含三个操作数-内存位置V、预期原值A、新值B，如果内存位置和预期原值相匹配，处理器自动将该位置的值改为新值，否则就不做处理CAS三大问题：ABA问题、循环时间长开销大、只能保证一个共享变量的原子操作，即一个CAS只能处理一个。7） 线程池如果使用一个线程就创建一个，存在如果并发的线程量大，且每个线程执行一个任务就结束了，这样频繁的创建线程就会给系统带来很大的开销，导致系统效率大大降低，因为频繁创建线程和销毁线程是需要时间的，而线程池可以对线程进行复用，大大减少线程建和销毁所带来的性能消耗。Thread和Runnable概念创建执行线程的两种方法：扩展Thread类以及实现Runnable接口重写Run方法线程的特征和状态：1） 不管是否并发，都有一个主线程的Thread对象，执行该程序时，java虚拟机会创建一个新的Thread并在该线程中执行main方法，这是非并发应用程序的唯一线程，也是并发应用程序中的第一个线程。2） Java线程共享应用程序中所有资源，包括内存和打开的文件，快速简单共享信息，但是需要使用同步，也就是加锁来避免数据竞争。3） Java线程的优先级，介于Thread.MAX_PRIORITY(10)和Thread.MIN_PRIORITY(1)之间，默认是5，通常较高优先级的线程会先于较低优先级的线程之前执行，但不是绝对，CPU可能会进行指令重排。4） Java的两种线程：守护线程和非守护线程，我们常用的多线程都是非守护线程Java程序结束执行的两种情形：第一种，通过执行Runtime类的exit()方法，用户具有可主动调用权力第二种，所有非守护线程执行完毕，JVM进程会自动退出，不会考虑守护线程运行情况。守护线程主要用于垃圾收集器或缓存管理器中，在start方法执行前通过isDaemon方法检查线程是否为守护线程，也可以通过setDaemon方法将某个线程指定为守护线程。5） Thread.States枚举类中定义的线程状态New: Thread对象已经创建还未执行Runnable: Thread对象已经在java虚拟机中运行Blocked：Thread对象正在等待锁定Waiting: Thread对象正在等待另一个线程的动作Time_Waiting: Thread对象正在等待另一个线程的动作,但是有时间限制Terminated: Thread对象已经完成了执行getState方法可以获取Thread对象的状态，并且修改，但是在给定时间内一个线程只能有一个状态。Thread和Runnable应用Runnable接口只定义了一种可实现的方法，即run方法，和继承Thread类是不一样的，当执行start方法启动新线程就会调用run方法。Thread类常用方法：1） 获取和设置Thread对象信息的方法：getId：返回Thread对象的标识符，他是线程创建分配的一个正整数，整个生命周期唯一且不能修改。getName/setName：获取或设置Thread对象的名称。getPriority/setPriority：获取或设置Thread对象的优先级。isDaemon/setDeamon：获取或者建立Threa对象的守护条件。getState：返回Thread对象的状态。2） Interrupt：中断目标线程，比如该线程处于sleep休眠中，使用它就可以直接唤醒，并给线程打上中断标记3） Interrupted：判断目标线程是否被中断，并清除该线程中断标记。4） Isinterrupted：判断目标线程是否被中断，但是不会清楚线程中断标记。5） Sleep(long ms)：线程执行暂停、休眠的时间。6） Join：暂停线程执行，直到调用该方法的线程执行结束为止，就是A B两个线程，B线程通过join方法切入到A线程中，那么A线程需要等待B线程执行完毕，他才能继续执行。7） setUncaughtExceptionHandler：用于建立未校验的异常处理器。8） currentThread：Thread类静态方法，返回实际执行该代码的Thread对象。', 0, '2023-04-14 20:04:08', '1646127543398469633', '2023-04-14 20:04:08', '1646127543398469633', 0, '	https://askbook-1317227518.cos.ap-beijing.myqcloud…k/images/f0c842f6-6dc0-40b1-9399-5edb02957217.png');

-- ----------------------------
-- Table structure for text_bridge
-- ----------------------------
DROP TABLE IF EXISTS `text_bridge`;
CREATE TABLE `text_bridge`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `text_id` bigint(21) NOT NULL COMMENT '文章id',
  `type_id` bigint(21) NOT NULL COMMENT '文章分类id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1646846797651394562 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章、文章分类桥接' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of text_bridge
-- ----------------------------
INSERT INTO `text_bridge` VALUES (1646133188969402371, 1646133188969402370, 1);
INSERT INTO `text_bridge` VALUES (1646746526199877633, 1646746525411348482, 1);
INSERT INTO `text_bridge` VALUES (1646747507792842753, 1646747507725733889, 2);
INSERT INTO `text_bridge` VALUES (1646749260026253315, 1646749260026253314, 3);
INSERT INTO `text_bridge` VALUES (1646843841480769537, 1646843841380106242, 3);
INSERT INTO `text_bridge` VALUES (1646843841480769538, 1646843841380106242, 4);
INSERT INTO `text_bridge` VALUES (1646844211493879810, 1646844211426770945, 7);
INSERT INTO `text_bridge` VALUES (1646844546065121283, 1646844546065121282, 3);
INSERT INTO `text_bridge` VALUES (1646844943014051842, 1646844942946942978, 5);
INSERT INTO `text_bridge` VALUES (1646844943014051843, 1646844942946942978, 6);
INSERT INTO `text_bridge` VALUES (1646846221337247746, 1646846221270138882, 9);
INSERT INTO `text_bridge` VALUES (1646846797584285698, 1646846797584285697, 5);
INSERT INTO `text_bridge` VALUES (1646846797651394561, 1646846797584285697, 10);

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `type` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '分类',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '分类' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, '知识');
INSERT INTO `type` VALUES (2, '科技');
INSERT INTO `type` VALUES (3, '影视');
INSERT INTO `type` VALUES (4, '法律');
INSERT INTO `type` VALUES (5, '音乐');
INSERT INTO `type` VALUES (6, '舞蹈');
INSERT INTO `type` VALUES (7, '运动');
INSERT INTO `type` VALUES (8, '医学');
INSERT INTO `type` VALUES (9, '汽车');
INSERT INTO `type` VALUES (10, '生活');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '姓名',
  `sex` bigint(11) NULL DEFAULT NULL COMMENT '性别:0男1女',
  `age` bigint(32) NULL DEFAULT NULL COMMENT '年龄',
  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '账号',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `phone` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `status` int(11) NULL DEFAULT 0 COMMENT '状态：0启用1禁用',
  `power` int(11) NULL DEFAULT 0 COMMENT '权限：0用户1管理员',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `image` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1646686871436144643 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, '管理员', 0, 22, 'admin', '21232f297a57a5a743894a0e4a801fc3', '15557849745', 0, 1, '2023-03-22 15:13:03', NULL, '2023-04-01 20:47:48');
INSERT INTO `user` VALUES (1646127543398469633, NULL, NULL, NULL, 'rosevvi', 'fcdc7b4207660a1372d0cd5491ad856e', NULL, 0, 0, '2023-04-12 20:26:05', NULL, '2023-04-12 20:26:05');
INSERT INTO `user` VALUES (1646684626040664065, NULL, NULL, NULL, 'loser', '6cb59bcb03e7a1edbe7573bc367307e8', NULL, 0, 0, '2023-04-14 09:19:43', NULL, '2023-04-14 09:19:43');
INSERT INTO `user` VALUES (1646686871436144642, NULL, NULL, NULL, 'curb', '043f9c4ee96b64fbd194e29f01217956', NULL, 0, 0, '2023-04-14 09:28:39', NULL, '2023-04-14 09:28:39');

-- ----------------------------
-- Table structure for user_like
-- ----------------------------
DROP TABLE IF EXISTS `user_like`;
CREATE TABLE `user_like`  (
  `id` bigint(20) NOT NULL COMMENT '主键',
  `question_id` bigint(20) NULL DEFAULT NULL COMMENT '问题id',
  `text_id` bigint(20) NULL DEFAULT NULL COMMENT '文章id',
  `user_id` bigint(20) NOT NULL COMMENT '用户id',
  `to_user_id` bigint(20) NOT NULL COMMENT '点赞那个用户的id',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '点赞' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user_like
-- ----------------------------
INSERT INTO `user_like` VALUES (1646689603870011394, 1646685927780659202, NULL, 1646127543398469633, 1646684626040664065, '2023-04-14 09:39:30');
INSERT INTO `user_like` VALUES (1646689661919178754, 1646687853217853441, NULL, 1646127543398469633, 1646686871436144642, '2023-04-14 09:39:44');
INSERT INTO `user_like` VALUES (1646689703186935810, 1646688417360130049, NULL, 1646127543398469633, 1646684626040664065, '2023-04-14 09:39:54');
INSERT INTO `user_like` VALUES (1646689755766730753, 1646688041907007489, NULL, 1646127543398469633, 1646686871436144642, '2023-04-14 09:40:06');
INSERT INTO `user_like` VALUES (1646689961451204609, 1646132967879249922, NULL, 1646684626040664065, 1646127543398469633, '2023-04-14 09:40:55');
INSERT INTO `user_like` VALUES (1646689992119955458, 1646683893044097025, NULL, 1646684626040664065, 1646127543398469633, '2023-04-14 09:41:03');
INSERT INTO `user_like` VALUES (1646690033819725826, 1646687543174901761, NULL, 1646684626040664065, 1646686871436144642, '2023-04-14 09:41:13');
INSERT INTO `user_like` VALUES (1646690068116549633, 1646688041907007489, NULL, 1646684626040664065, 1646686871436144642, '2023-04-14 09:41:21');
INSERT INTO `user_like` VALUES (1646690099540275201, 1646688765579636738, NULL, 1646684626040664065, 1646127543398469633, '2023-04-14 09:41:28');
INSERT INTO `user_like` VALUES (1646690235326672897, 1646683893044097025, NULL, 1646686871436144642, 1646127543398469633, '2023-04-14 09:42:01');
INSERT INTO `user_like` VALUES (1646690260718989314, 1646132967879249922, NULL, 1646686871436144642, 1646127543398469633, '2023-04-14 09:42:07');
INSERT INTO `user_like` VALUES (1646690295179390977, 1646684126339674113, NULL, 1646686871436144642, 1646127543398469633, '2023-04-14 09:42:15');
INSERT INTO `user_like` VALUES (1646690331581755393, 1646685927780659202, NULL, 1646686871436144642, 1646684626040664065, '2023-04-14 09:42:24');
INSERT INTO `user_like` VALUES (1646690366570639362, 1646688765579636738, NULL, 1646686871436144642, 1646127543398469633, '2023-04-14 09:42:32');
INSERT INTO `user_like` VALUES (1646847496284028929, NULL, 1646746525411348482, 1646127543398469633, 1646686871436144642, '2023-04-14 20:06:55');
INSERT INTO `user_like` VALUES (1646847531314855937, NULL, 1646747507725733889, 1646127543398469633, 1646686871436144642, '2023-04-14 20:07:03');
INSERT INTO `user_like` VALUES (1646847556564566017, NULL, 1646749260026253314, 1646127543398469633, 1646686871436144642, '2023-04-14 20:07:09');
INSERT INTO `user_like` VALUES (1646847622125731841, NULL, 1646844211426770945, 1646127543398469633, 1646684626040664065, '2023-04-14 20:07:25');
INSERT INTO `user_like` VALUES (1646847712231964674, NULL, 1646846221270138882, 1646127543398469633, 1646684626040664065, '2023-04-14 20:07:46');
INSERT INTO `user_like` VALUES (1646847826614829058, NULL, 1646133188969402370, 1646684626040664065, 1646127543398469633, '2023-04-14 20:08:13');
INSERT INTO `user_like` VALUES (1646847857291968513, NULL, 1646746525411348482, 1646684626040664065, 1646686871436144642, '2023-04-14 20:08:21');
INSERT INTO `user_like` VALUES (1646847887381905410, NULL, 1646846797584285697, 1646684626040664065, 1646127543398469633, '2023-04-14 20:08:28');
INSERT INTO `user_like` VALUES (1646847949445021697, NULL, 1646133188969402370, 1646686871436144642, 1646127543398469633, '2023-04-14 20:08:43');
INSERT INTO `user_like` VALUES (1646847982852653057, NULL, 1646843841380106242, 1646686871436144642, 1646127543398469633, '2023-04-14 20:08:51');
INSERT INTO `user_like` VALUES (1646848014469316610, NULL, 1646844211426770945, 1646686871436144642, 1646684626040664065, '2023-04-14 20:08:58');
INSERT INTO `user_like` VALUES (1646848052784283649, NULL, 1646844942946942978, 1646686871436144642, 1646127543398469633, '2023-04-14 20:09:07');

SET FOREIGN_KEY_CHECKS = 1;
